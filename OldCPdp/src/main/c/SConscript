# main SConscript
import sys, os, platform
import glob, re, fileinput, stat
from time import localtime, strftime

if "config" not in sys.path:
 sys.path.insert(0, "config")
import logConf

#######################################################################
# Auxiliary method definitions
def dirList(self, basePath, top, fileListing=False):
  liste=[]
  for root, subFolders, files in os.walk(top):
    if ".svn" in root:
      continue
    if fileListing==False:
      if subFolders!=[]:
        for a in subFolders:
          if a==".svn":
            continue
          liste.insert(0, os.path.join(basePath, root, a))
    else:
      for e in files:
        liste.append(os.path.join(root, e))
  return liste

def rdObject(self, source, target = None, ccflags = None):
  sourceLog=env.pefLogger(source)
  Depends(sourceLog, env.Alias('pefLoggerConfig'))
  Depends(sourceLog, env.Alias('pdpConfig'))

  sourceObject=None
  if ccflags==None:
    ccflags=env['CCFLAGS']
    
  if env['android']==True:
    return sourceLog
  else:
    if target!=None:
      sourceObject=env.Object(target, source, CCFLAGS=ccflags)
    else:
      sourceObject=env.Object(source, CCFLAGS=ccflags)
    Depends(sourceObject, sourceLog)
  return sourceObject
  
AddMethod(Environment, rdObject)

#def Alias(self, alias, objects):
#  print "rdAlias invoked"
#AddMethod(Environment, Alias)

def rdAlias(self, alias, objects):
  curTarget=env['PEFtarget']
  if alias in env['PEFobjects'][curTarget]:
    env['PEFobjects'][curTarget][alias].append(objects)
  else:
    env['PEFobjects'][curTarget][alias] = objects
AddMethod(Environment, rdAlias)  

def getAliasObjects(self, alias):
  #objects = env.Alias(alias)[0].all_children()
  #print objects
  #print "alias: " + alias
  #print "generating list of alias-objects for platform: " + env['PEFtarget']
  #listPlatformObjects=[]
  #for obj in objects:
  #  if env['PEFtarget'] in str(obj):
  #    print "found for object: " + str(obj)
  #    listPlatformObjects.append(obj)
  #  else:
  #    print "skipping incompatible object: " + str(obj)
  #return env.Alias(alias)[0].all_children()
  curTarget=env['PEFtarget']
  #print "requesting aliases for target="+curTarget
  if not alias in env['PEFobjects'][curTarget]:
    #print "nothing defined for alias '" + alias + "'"
    return []
  #print "returning ["+alias+"]: " + str(env['PEFobjects'][curTarget][alias])
  return env['PEFobjects'][curTarget][alias]
AddMethod(Environment, getAliasObjects)

#######################################################################
# folder structure: basePath:  pef/src/main/c 
#                 : buildPath: pef/bin/platform.system
basePath =os.getcwd()
buildPath=os.path.join(basePath, "..","..", "..", "bin", str.lower(platform.system()+"-"+platform.machine()))

#######################################################################
tmpConfig={}
tmpConfig['PEFBASE']    =basePath

#######################################################################
# Processing cross-compilation options...
Import('target')
#if ARGUMENTS.get('target') == "win32" or ARGUMENTS.get('target') == "win64":
if target == "win32" or target == "win64":
  tmpConfig['PEFtarget'] = target
  tmpConfig['PEFBUILD'] = os.path.join(basePath, "..","..", "..", "bin", target)
else:
  tmpConfig['PEFtarget'] = "native"
  tmpConfig['PEFBUILD']   =buildPath

tmpConfig['PEFincludes']=dirList(None, basePath, 'include')


#######################################################################
# fetch platform and user specific configuration
env = SConscript("config/SConscript", exports=['tmpConfig'])
AddMethod(Environment, dirList)

pefLoggerAction = Action(logConf.pefLoggerBuildFunction, cmdstr="Preparing pefLogger ['$SOURCE']")
pefLoggerBuilder = Builder(action = pefLoggerAction, src_suffix='.c', suffix = '_pef.h', prefix = 'log_')
env.Append(BUILDERS = {'pefLogger' : pefLoggerBuilder})

pefLoggerConfigAction = Action(logConf.pefLoggerConfigBuildFunction, cmdstr="Preparing pefLogger configuration")
pefLoggerConfigBuilder = Builder(action = pefLoggerConfigAction)
env.Append(BUILDERS = {'pefLoggerConfig' : pefLoggerConfigBuilder})


#######################################################################
# processing command line arguments
if ARGUMENTS.get('nodebugger') != "1":
  env.Prepend(CCFLAGS = ' -g ')
  
if ARGUMENTS.get('profiler') == "1":
  env.Prepend(CCFLAGS   = ' -pg ')
  env.Prepend(LINKFLAGS = ' -pg ')
  
if ARGUMENTS.get('strict') == "1":
  env.Prepend(CCFLAGS = ' -Wall ')

# Need to separate different commands (gcc, g++, ar, ...) manually
def printCommand(s, target, src, env):
    #s is the original command line, target and src are lists of target and source nodes respectively, and env is the environment.
    sys.stdout.write(" Compiling %s...\n"%(' and '.join([str(x) for x in target])))

if ARGUMENTS.get('verbose') != "1":
  #env['PRINT_CMD_LINE_FUNC'] = printCommand
  env.Replace(CCCOMSTR     = "Compiling $TARGET")
  env.Replace(CXXCOMSTR    = "Compiling C++ $TARGET")
  env.Replace(LINKCOMSTR   = "Linking $TARGET")
  env.Replace(SHCCCOMSTR   = "Compiling shared library $TARGET")
  env.Replace(SHCXXCOMSTR  = "Compiling C++ shared library $TARGET")  
  env.Replace(SHLINKCOMSTR = "Linking shared library $TARGET")
  env.Replace(ARCOMSTR     = "Archiving static library $TARGET")
  env.Replace(RANLIBCOMSTR = "Indexing static library $TARGET")
  env.Append(VERBOSE       = 0)
else:
  env.Append(VERBOSE       = 1)

#######################################################################
# Configuration checking
#print "Checking system configuration..." 
##env.ParseConfig("pkg-config x11 --cflags --libs")
#if not GetOption('clean') and not GetOption('help'):
#  errors = False
#  conf = Configure(env, clean = False, help = False)
#
#  if not conf.CheckCC():
#    errors = True
#  if not conf.CheckLib('glib-2.0'):
#    print "searched in: " + str(env['CPPPATH'])
#    errors=True
#  if not conf.CheckLib('xml2'):
#    errors=True
#  if env['PEFCONFIG']['tssUtils'] == True:
#    if not conf.CheckLib('tspi'):
#      errors=True
#  if env['PEFCONFIG']['cryptoUtils'] == True:
#    if not conf.CheckLib('crypto'):
#      errors=True
#  if not conf.CheckLib('pthread'):
#    errors=True
#  if env['PEFCONFIG']['pdpjni'] == True and not ARGUMENTS.get('conf', '')=="android":
#    if not conf.CheckCHeader('jni.h'):
#      print "searched in: " + str(env['CPPPATH'])
#      errors=True
#
#  if errors == True:
#    print "Error occured in configuration check..."
#    #Exit(1)
#  env = conf.Finish()


Help("\nscons               build entire PEF\n"
       "scons -c            clean up entire PEF\n"
       "scons strict=1      printing all compiler warnings (-Wall)\n"
       "scons verbose=1     printing compiler commands instead of descriptions\n"
       "scons nodebugger=1  don't include debugger symbols (NOT use -g)\n"
       "scons profiler=1    include GNU profiler information (-pg)\n"
    ) 

Return('env')





