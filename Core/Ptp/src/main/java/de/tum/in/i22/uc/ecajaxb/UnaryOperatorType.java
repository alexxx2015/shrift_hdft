//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.0 in JDK 1.6 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2013.05.25 at 01:44:24 PM CEST 
//


package de.tum.in.i22.uc.ecajaxb;

import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlTransient;
import javax.xml.bind.annotation.XmlType;


/**
 * <p>Java class for UnaryOperatorType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="UnaryOperatorType">
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;group ref="{http://www.iese.fhg.de/pef/1.0/enforcementLanguage}OperatorsGroup"/>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "UnaryOperatorType", propOrder = {
    "_true",
    "_false",
    "eventMatch",
    "not",
    "and",
    "or",
    "implies",
    "xPathEval",
    "eventually",
    "stateBasedFormula",
    "since",
    "always",
    "before",
    "during",
    "within",
    "repLim",
    "repSince",
    "repMax"
})
public class UnaryOperatorType implements IOperatorType{

    @XmlElement(name = "true")
    protected EmptyOperatorType _true;
    @XmlElement(name = "false")
    protected EmptyOperatorType _false;
    protected EventMatchingOperatorType eventMatch;
    protected UnaryOperatorType not;
    protected BinaryOperatorType and;
    protected BinaryOperatorType or;
    protected BinaryOperatorType implies;
    protected String xPathEval;
    protected UnaryOperatorType eventually;
    protected StateBasedOperatorType stateBasedFormula;
    protected BinaryOperatorType since;
    protected UnaryOperatorType always;
    protected TimeBoundedUnaryOperatorType before;
    protected TimeBoundedUnaryOperatorType during;
    protected TimeBoundedUnaryOperatorType within;
    protected TimeBoundedUnaryOperatorType.RepLim repLim;
    protected TimeBoundedUnaryOperatorType.RepSince repSince;
    protected TimeBoundedUnaryOperatorType.RepMax repMax;
    
    @XmlTransient 
    private boolean isNot;
    @XmlTransient
    private boolean isEventually;
    @XmlTransient
    private boolean isAlways;    
    @XmlTransient
    private Object oParentToPass;
    @XmlTransient 
    private boolean isTrue;
    @XmlTransient
    private boolean isFalse;

    public boolean isTrue(){
    	return isTrue;
    }
    
    private void setTrue(){
    	this.isTrue = true;
    }
    
    public boolean isFalse(){
    	return isFalse;
    }
    
    private void setFalse(){
    	this.isFalse = true;
    }
    
    /**
     * 
     * @return Returns if this operator is <not> or not
     */
    public boolean isNot() {
		return isNot;
	}

    /**
     * Sets that this operator is <not> or not
     * 
     * @param isNot
     */
	public void setNot(boolean isNot) {
		this.isNot = isNot;
	}

	/**
	 * 
	 * @return Returns if this operator is <eventually> or not
	 */
	public boolean isEventually() {
		return isEventually;
	}

	/**
	 * Sets that this operator is <eventually> or not
	 * 
	 * @param isEventually
	 */
	public void setEventually(boolean isEventually) {
		this.isEventually = isEventually;
	}

	/**
	 * 
	 * @return Returns if this operator is <always> or not
	 */
	public boolean isAlways() {
		return isAlways;
	}

	/**
	 * Sets that this operator is <always> or not
	 * 
	 * @param isAlways
	 */
	public void setAlways(boolean isAlways) {
		this.isAlways = isAlways;
	}
	
	/**
	 * 
	 * @return Returns the parent to pass to the next recursive step
	 */
	public Object getParentToPass(){
		return oParentToPass;
	}

    /**
     * Gets the value of the true property.
     * 
     * @return
     *     possible object is
     *     {@link EmptyOperatorType }
     *     
     */
    public EmptyOperatorType getTrue() {
        return _true;
    }

    /**
     * Sets the value of the true property.
     * 
     * @param value
     *     allowed object is
     *     {@link EmptyOperatorType }
     *     
     */
    public void setTrue(EmptyOperatorType value) {
        this._true = value;
        this.setTrue();
    }

    /**
     * Gets the value of the false property.
     * 
     * @return
     *     possible object is
     *     {@link EmptyOperatorType }
     *     
     */
    public EmptyOperatorType getFalse() {
        return _false;
    }

    /**
     * Sets the value of the false property.
     * 
     * @param value
     *     allowed object is
     *     {@link EmptyOperatorType }
     *     
     */
    public void setFalse(EmptyOperatorType value) {
        this._false = value;
        this.setFalse();
    }

    /**
     * Gets the value of the eventMatch property.
     * 
     * @return
     *     possible object is
     *     {@link EventMatchingOperatorType }
     *     
     */
    public EventMatchingOperatorType getEventMatch() {
        return eventMatch;
    }

    /**
     * Sets the value of the eventMatch property.
     * 
     * @param value
     *     allowed object is
     *     {@link EventMatchingOperatorType }
     *     
     */
    public void setEventMatch(EventMatchingOperatorType value) {
        this.eventMatch = value;
    }

    /**
     * Gets the value of the not property.
     * 
     * @return
     *     possible object is
     *     {@link UnaryOperatorType }
     *     
     */
    public UnaryOperatorType getNot() {
        return not;
    }

    /**
     * Sets the value of the not property.
     * 
     * @param value
     *     allowed object is
     *     {@link UnaryOperatorType }
     *     
     */
    public void setNot(UnaryOperatorType value) {
        this.not = value;
    }

    /**
     * Gets the value of the and property.
     * 
     * @return
     *     possible object is
     *     {@link BinaryOperatorType }
     *     
     */
    public BinaryOperatorType getAnd() {
        return and;
    }

    /**
     * Sets the value of the and property.
     * 
     * @param value
     *     allowed object is
     *     {@link BinaryOperatorType }
     *     
     */
    public void setAnd(BinaryOperatorType value) {
        this.and = value;
    }

    /**
     * Gets the value of the or property.
     * 
     * @return
     *     possible object is
     *     {@link BinaryOperatorType }
     *     
     */
    public BinaryOperatorType getOr() {
        return or;
    }

    /**
     * Sets the value of the or property.
     * 
     * @param value
     *     allowed object is
     *     {@link BinaryOperatorType }
     *     
     */
    public void setOr(BinaryOperatorType value) {
        this.or = value;
    }

    /**
     * Gets the value of the implies property.
     * 
     * @return
     *     possible object is
     *     {@link BinaryOperatorType }
     *     
     */
    public BinaryOperatorType getImplies() {
        return implies;
    }

    /**
     * Sets the value of the implies property.
     * 
     * @param value
     *     allowed object is
     *     {@link BinaryOperatorType }
     *     
     */
    public void setImplies(BinaryOperatorType value) {
        this.implies = value;
    }

    /**
     * Gets the value of the xPathEval property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getXPathEval() {
        return xPathEval;
    }

    /**
     * Sets the value of the xPathEval property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setXPathEval(String value) {
        this.xPathEval = value;
    }

    /**
     * Gets the value of the eventually property.
     * 
     * @return
     *     possible object is
     *     {@link UnaryOperatorType }
     *     
     */
    public UnaryOperatorType getEventually() {
        return eventually;
    }

    /**
     * Sets the value of the eventually property.
     * 
     * @param value
     *     allowed object is
     *     {@link UnaryOperatorType }
     *     
     */
    public void setEventually(UnaryOperatorType value) {
        this.eventually = value;
    }

    /**
     * Gets the value of the stateBasedFormula property.
     * 
     * @return
     *     possible object is
     *     {@link StateBasedOperatorType }
     *     
     */
    public StateBasedOperatorType getStateBasedFormula() {
        return stateBasedFormula;
    }

    /**
     * Sets the value of the stateBasedFormula property.
     * 
     * @param value
     *     allowed object is
     *     {@link StateBasedOperatorType }
     *     
     */
    public void setStateBasedFormula(StateBasedOperatorType value) {
        this.stateBasedFormula = value;
    }

    /**
     * Gets the value of the since property.
     * 
     * @return
     *     possible object is
     *     {@link BinaryOperatorType }
     *     
     */
    public BinaryOperatorType getSince() {
        return since;
    }

    /**
     * Sets the value of the since property.
     * 
     * @param value
     *     allowed object is
     *     {@link BinaryOperatorType }
     *     
     */
    public void setSince(BinaryOperatorType value) {
        this.since = value;
    }

    /**
     * Gets the value of the always property.
     * 
     * @return
     *     possible object is
     *     {@link UnaryOperatorType }
     *     
     */
    public UnaryOperatorType getAlways() {
        return always;
    }

    /**
     * Sets the value of the always property.
     * 
     * @param value
     *     allowed object is
     *     {@link UnaryOperatorType }
     *     
     */
    public void setAlways(UnaryOperatorType value) {
        this.always = value;
    }

    /**
     * Gets the value of the before property.
     * 
     * @return
     *     possible object is
     *     {@link TimeBoundedUnaryOperatorType }
     *     
     */
    public TimeBoundedUnaryOperatorType getBefore() {
        return before;
    }

    /**
     * Sets the value of the before property.
     * 
     * @param value
     *     allowed object is
     *     {@link TimeBoundedUnaryOperatorType }
     *     
     */
    public void setBefore(TimeBoundedUnaryOperatorType value) {
        this.before = value;
    }

    /**
     * Gets the value of the during property.
     * 
     * @return
     *     possible object is
     *     {@link TimeBoundedUnaryOperatorType }
     *     
     */
    public TimeBoundedUnaryOperatorType getDuring() {
        return during;
    }

    /**
     * Sets the value of the during property.
     * 
     * @param value
     *     allowed object is
     *     {@link TimeBoundedUnaryOperatorType }
     *     
     */
    public void setDuring(TimeBoundedUnaryOperatorType value) {
        this.during = value;
    }

    /**
     * Gets the value of the within property.
     * 
     * @return
     *     possible object is
     *     {@link TimeBoundedUnaryOperatorType }
     *     
     */
    public TimeBoundedUnaryOperatorType getWithin() {
        return within;
    }

    /**
     * Sets the value of the within property.
     * 
     * @param value
     *     allowed object is
     *     {@link TimeBoundedUnaryOperatorType }
     *     
     */
    public void setWithin(TimeBoundedUnaryOperatorType value) {
        this.within = value;
    }

    /**
     * Gets the value of the repLim property.
     * 
     * @return
     *     possible object is
     *     {@link TimeBoundedUnaryOperatorType.RepLim }
     *     
     */
    public TimeBoundedUnaryOperatorType.RepLim getRepLim() {
        return repLim;
    }

    /**
     * Sets the value of the repLim property.
     * 
     * @param value
     *     allowed object is
     *     {@link TimeBoundedUnaryOperatorType.RepLim }
     *     
     */
    public void setRepLim(TimeBoundedUnaryOperatorType.RepLim value) {
        this.repLim = value;
    }

    /**
     * Gets the value of the repSince property.
     * 
     * @return
     *     possible object is
     *     {@link TimeBoundedUnaryOperatorType.RepSince }
     *     
     */
    public TimeBoundedUnaryOperatorType.RepSince getRepSince() {
        return repSince;
    }

    /**
     * Sets the value of the repSince property.
     * 
     * @param value
     *     allowed object is
     *     {@link TimeBoundedUnaryOperatorType.RepSince }
     *     
     */
    public void setRepSince(TimeBoundedUnaryOperatorType.RepSince value) {
        this.repSince = value;
    }

    /**
     * Gets the value of the repMax property.
     * 
     * @return
     *     possible object is
     *     {@link TimeBoundedUnaryOperatorType.RepMax }
     *     
     */
    public TimeBoundedUnaryOperatorType.RepMax getRepMax() {
        return repMax;
    }

    /**
     * Sets the value of the repMax property.
     * 
     * @param value
     *     allowed object is
     *     {@link TimeBoundedUnaryOperatorType.RepMax }
     *     
     */
    public void setRepMax(TimeBoundedUnaryOperatorType.RepMax value) {
        this.repMax = value;
    }
    
    

	@Override
	public OperatorTypeValue tellOperatorType() {
		
		return OperatorTypeValue.UNARY;
	}

	@Override
	public void configureMyself(String xmlNodeName, Object parent) {
		
		if(xmlNodeName.equalsIgnoreCase("not")){				
			setNot(true);					
		}
		else if(xmlNodeName.equalsIgnoreCase("eventually")){				
			setEventually(true);							
		}
		else if(xmlNodeName.equalsIgnoreCase("always")){				
			setAlways(true);					
		}
		else if(xmlNodeName.equalsIgnoreCase("true")){				
			setTrue(new EmptyOperatorType());				
		}
		else if(xmlNodeName.equalsIgnoreCase("false")){				
			setFalse(new EmptyOperatorType());
		}
		
		connectToMyParent(parent);
		oParentToPass=this;
	}

	@Override
	public void connectToMyParent(Object parent) {
		
		ObjectFactory factory=new ObjectFactory();
		if(parent!=null){
			if(parent instanceof UnaryOperatorType){
				UnaryOperatorType uotParent=(UnaryOperatorType) parent;
				if(isAlways()) uotParent.setAlways(this);
				else if(isEventually()) uotParent.setEventually(this);
				else if(isNot()) uotParent.setNot(this);
			}
			else if(parent instanceof BinaryOperatorType){
				BinaryOperatorType botParent=(BinaryOperatorType) parent;					
				JAXBElement<UnaryOperatorType> el;
				if(isAlways()) {
					el=factory.createBinaryOperatorTypeAlways(this);
					botParent.getOperatorsGroup().add(el);
				}
				else if(isEventually()) {
					el=factory.createBinaryOperatorTypeEventually(this);
					botParent.getOperatorsGroup().add(el);
				}
				else if(isNot()) {
					el=factory.createBinaryOperatorTypeNot(this);
					botParent.getOperatorsGroup().add(el);
				}
				else if(isFalse()){
					JAXBElement<EmptyOperatorType> elFalse = factory.createBinaryOperatorTypeFalse(new EmptyOperatorType());
					botParent.getOperatorsGroup().add(elFalse);
				}
				else if(isTrue()){
					JAXBElement<EmptyOperatorType> elTrue = factory.createBinaryOperatorTypeTrue(new EmptyOperatorType());
					botParent.getOperatorsGroup().add(elTrue);
				}
			}
			else if(parent instanceof TimeBoundedUnaryOperatorType){
				 TimeBoundedUnaryOperatorType tbotParent = (TimeBoundedUnaryOperatorType) parent;
					if(isAlways()) tbotParent.setAlways(this);
					else if(isEventually()) tbotParent.setEventually(this);
					else if(isNot()) tbotParent.setNot(this);
				
			}
		
		}
		
	}

}
